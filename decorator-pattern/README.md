#### 3、装饰器模式
装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。
装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。

在装饰模式中的角色有：
* 抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。
* 具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。
* 装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。
* 具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。

装饰模式降低系统的耦合度，可以动态的增加或删除对象的职责，并使得需要装饰的具体构建类和具体装饰类可以独立变化，以便增加新的具体构建类和具体装饰类。
装饰模式是为了增加新的功能。

开发中使用的场景：
IO中输入流和输出流的设计、Servlet API中提供了一个request对象的Decorator设计模式的默认实现类HttpServletRequestWrapper，HttpServletRequestWrapper类增强了request对象的功能。

`v1 jar包`：模拟一个简单的装饰器模式的使用
`v2 jar包`：简单模拟一下ServletHttp的设计